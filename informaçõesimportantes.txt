----------------------------------------------------------------------
git init
git add README.md ou git add .
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/BManduca/Nome_diretorio.git
git push -u origin main
----------------------------------------------------------------------

Next.js
  - quando utilizamos o Next dentro do React, temos o funcionamento totalmente automatizado.
  - quando desabilitamos o javascript, somente será desabilitado do lado do client, do browser e assim, 
  fica claro, que se tudo se manteve como era, ou seja, que a interface não esta sendo construída 
  pelo javascript do client-side e sim pelo javascript que ta rodando la dentro do nosso serviço
  com o Next em si. 

  Aula 02:
  typescript:
    - Ajuda na escrita, na hora da chamada das funções.
    - Será utilizado bastante o typescript dentro dos componentes do React.
      - principalmente na parte de tipagem das propriedades de um component.
    - Ajuda a não cometer erros e ter mais segurança na manutenção do código, 
    onde o próprio editor vai avisar, se estamos chamando algo errado ou passando 
    um parâmetro errado, facilitando assim o codar ou a manutenção.

    - comandos:
      - sudo yarn dev: subir o server
      - sudo yarn add typescript @types/react @types/node -D
        - typescript é o próprio TS
        - @types/react: integração do react com o TS
        - @types/node: integração do node com o TS
        Algumas bibliotecas trazem essa integração junto da própria biblioteca, outras criam um pacote terceiros, desta forma, 
        sempre é preciso instalar a parte
        - será instalado como dependência de desenvolvimento, porque o typescript só roda em desenvolvimento, em produção
        o código é convertido totalmente para javascript, que não tem tipagem, sendo assim, em produção não precisa dessa 
        dependência.

    - curiosidades: 
      - porque .tsx?
        - Essa extensão vem de: typescript + jsx
          - jsx é a sintaxe de (xml no javascript)

    - SASS: 
      - pré-processador CSS, que permite escrever o CSS de uma maneira diferente
      - permite o encadeamento(cascata) de CSS
      - Formato passa de .css para .scss

      root -> local aonde será definido as variáveis css que estarão definidos para todo projeto.

      - uso da medida rem
        - para grande maioria de medidas de tamanho, fonts e tudo mais...
        - mas porque?
          - para cada rem, equivale ao tamanho do font-size do meu root(html), por isso
          a sigla rem, ou seja, 'root em'
          - se fosse so em, ele pegaria  tamanho relativo ao elemento que está por volta 
          daquele texto, mas ao colocar rem, estará usando o tamanho relativo ao root da minha
          página, ou seja, meu html...
            - Exemplo:
              html {
                font-size: 10px;
              }

              h1 {
                font-size: 2rem; //o 2rem é equivalente a 2 * 10px = 20px;
              }

            - outra questão, caso a tela do user seja um pouco menor:
              @media (max-width: 1080px) {
                html {
                  font-size: 93.75%; //15px -> 16 * 0,9375
                }
              }
              - essa porcentagem vai refatorar todo o tamanho, para que não 
              fique algo desproporcional da tela do user com relação ao texto, 
              trazendo assim uma UX desconfortável para o user.

    - Fontes utilizadas no projeto: 
      - acessar fonts.google.com
      - pegar as fontes Lexend e inter

      - na pasta pages, por padrão o next traz um arquivo chamado app
        - este arquivo, automaticamente fica por volta de todas as páginas do app, 
        pois ele é basicamente um arquivo global.
        - O next tem um sistemas de rotas próprios, por exemplo acessando 
        a rota principal do meu app, acaba 'caindo' no index, 
        se existisse outro arquivo, como contato.tsx por exemplo e acessasse 
        esta rota, automaticamente iria acessar o arquivo contato.tsx
        - A chamar qualquer outra rota ou arquivo, o app sempre será chamado 
        em conjunto

        - criando um arquivo _document.tsx
          - arquivo para configurar qual é o documento, qual que é  
          formato do HTML
          - no create-react-app, na pasta public tinha um arquivo index.html e
          neste arquivo tinha html, head, body... No next nã temos este arquivo, 
          por isso, se quisermos customizar o conteúdo daquele html, precisamos 
          fazer via o _document.tsx, este arquivo ficara em volta de toda nossa aplicação, 
          porém, ele será chamado uma única vez.
          - dentro do _document.tsx, temos o Html, dentro do mesmo temos as 
          tags head e body, dentro do body temos as tags Main e NextScript, no main
          é aonde ficará toda nossa aplicação e no NextScript, é aonde rodará 
          todos os scripts que o next precisa implementa/injeta na nossa aplicação
          para que ela funcione .


- No react ao utilizarmos classes, não chamamos as mesmas via class, mas através de 
className, que é uma particularidade do próprio react e também o class em si, é uma 
palavra reservada do javascript.
- Hoje conseguimos criar arquivos css específicos de um componente, as regras por exemplo
do header nunca serão compartilhadas com outros componentes da nossa aplicação, outro exemplo,
é se  que eu estivesse estilizando fosse um title, eu não precisaria me preocupar se na minha 
aplicação tem outro title, porque essa estilização que eu to fazendo é especifica para o arquivo 
que está no Header, então na hora de importar no index.tsx, podemos importar da seguinte forma:
import styles from './styles.module.scss' e no className do header, colocamos entre {}, pois,
estaremos colocando uma variável javascript dentro, ficando da seguinte forma:
<header className={styles.headerContainer}>...</header>

- No span, foi colocado uma estilização da seguinte forma: 
margin-left: auto; e text-transform: capitalize;, onde  margin-left sendo auto, 
faz com que todo o espaço a esquerda seja utilizado e o text-transform sendo capitalize, será
colocado sempre a primeira letra das palavras sempre em maiúsculo.

- Para estilizar e mexer com data no javascript, resultando em uma melhor experiência, vamos add 
a biblioteca date-fns do yarn da seguinte forma: sudo yarn add date-fns

- Para pegar a data current da região aonde eu moro, podemos fazer da seguinte forma: 
  const currentDate = format(new Date(), 'EEEEEE, d MMMM',{
    locale: ptBR,
  });

  Onde: EEEEEE significa que o dia da semana estará no formato Mo, Tu, We, Th, Fr, Su, Sa, 
  o d é o dia do mês nesse formato: 1, 2, ..., 31 e o MMMM é o nome do mês, que estará no formato 
  January, February, ..., December


- Criação do player: 
  - Criamos a pasta(diretório) do Player, com base no do header
  - criamos um um .scss para estilizar o app (app.module.scss)
    - onde foi definido no _app.tsx uma className como styles.wrapper
    - no scss colocamos o display como flex
    - tag main que tem dentro do wrapper tem um flex 1, ou seja, ocupe o máximo do 
    espaço possível e seja flexível.
    - no index.tsx, na div presente no return colocamos uma className={styles.playerContainer}
    e no arquivo styles.module.scss de estilização, definimos o width: 26.5rem e o
  height: 100vh, so explicando o 100vh condiz com 100% do viewport, ou seja, o máximo da
  altura da tela. 

- JSON.stringify:
  - O método JSON.stringify() converte valores em javascript para uma String  JSON. Esses valores 
  podem ser substituídos especificando a função replacer, ou incluindo somente as propriedades específicas, 
  quando o array do replacer for especificado.

  - Sintaxe: JSON.stringify(valor[, replacer[, espaço]])
    > valor: O valor a ser convertido para uma string JSON.

    > replacer: Uma função que altera o comportamento do processo de transformação em string, ou um array 
    de objetos String e Number que servem como uma lista branca para selecionar as propriedades do objeto 
    valor a ser incluído na string JSON. Se este valor for nulo ou não fornecido, todas as propriedades do 
    objeto são incluídas na string JSON resultante.

    > espaço: Um objeto String ou Number que é usado para inserir espaço em branco na saída da string 
    JSON para propósito de legibilidade. Se isto for um Number, indica o número de caracteres espaço para 
    usar como espaço em branco; este número é limitado em 10 se for maior que isso. Valores menores que 1 
    indicam que nenhum espaço deve ser usado. Se isto for uma String, a string (ou os primeiros 10 caracteres 
    da string, se for maior que isso) é usado como espaço em branco. Se esse parâmetro não for fornecido (ou for null), 
    nenhum espaço em branco é usado.


- Maneiras de consumir uma API:

- SPA
  - no SPA existe uma função que vem de dentro do React, chamada useEffect(), onde ela basicamente 
  é uma função do React que dispara algo sempre que algo mudar na nossa aplicação, ou seja, algum efeito colateral.
  - no arquivo index.tsx: 
      import { useEffect } from "react"

      export default function Home(props) {
      //usando SPA
      useEffect(() => {
        fetch('http://localhost:3333/episodes')
        .then(response => response.json())
        .then(data => console.log(data))
      },[])
      return (
        <div>
          <h1>Index</h1>
          <p>{JSON.stringify(props.episodes)}</p>
        </div>
      )
    }

- SSR
  - ficaria da seguinte forma:

      export default function Home(props) {
        return (
          <div>
            <h1>Index</h1>
            <p>{JSON.stringify(props.episodes)}</p>
          </div>
        )
      }

      //utilizando o SSR
      export async function getServerSideProps() {
        const response = await fetch('http://localhost:3333/episodes')
        const data = await response.json()

        return {
          props: {
            episodes: data,
          }
        }
      }


- SSG:
    - ficaria da seguinte forma:
  
      export default function Home(props) {
        return (
          <div>
            <h1>Index</h1>
            <p>{JSON.stringify(props.episodes)}</p>
          </div>
        )
      }

      //Para utilizar o SSG, basta trocar o nome da function
      export async function getStaticProps() {
        const response = await fetch('http://localhost:3333/episodes')
        const data = await response.json()

        return {
          props: {
            episodes: data,
          },
          //o revalidate recebe um numero em segundos, de quanto em quanto tempo, eu gostaria que gerasse uma 
          // nova versão desta página
          revalidate:
        }
      }

- Rodando o servidor:
  - sudo yarn server

- montando uma build do projeto:
  - sudo yarn build

- Rodar o projeto como se estivesse em produção:
  - sudo yarn start, gerando assim a nossa pagina de forma estática.



Aula 03: 

- ao realizar o import { GetStaticProps } from 'next';
  - Estaremos definindo a tipagem da função, determinando o formato da função, o retorno da função.
  - Para tipar a 'função' por completo, transformamos a function em uma constante(const), da seguinte forma:
      - export const getStaticProps: GetStaticProps = async () => {
        // fazendo desta forma, tanto os parâmetros da function quanto o return estão tipados.
      }


- Criando um tipo HomeProps, que são as propriedades que o component home recebe:
  - type/interface HomeProps {
        //episodes é um array de objects
        episodes: Array<{
            id: string;
            title: string;
            members: string;
            //...
        }>
    }

    - formas para declarar um array em typescript: 
      type HomeProps = {
        episodes: Array<Episode>;
        //ou episodes: Episode[];
      }

    - aplicando propriedades através do fetch, para organizar os podcasts:
      - o fetch é uma API que vem já dentro do browser.
      - fetch('http://localhost:3333/episodes?_limit=12&_sort=published_at&_order=desc')
        - onde: 
          - o _limit, estará limitando o número de podcasts por page
          - _sort, estará ordenando por um campo específico, definido pelo dev
          - _order, estará identificando se vai ser decrescente ou crescente.
      - uma alternativa para o fetch, até em projetos maiores, seria o axios.
          - sudo yarn add axios
            - O axios é uma biblioteca, para fazer requisições http, assim como  próprio fetch,
            porém, ele trás algumas funcionalidades a mais, que não são encontradas no fetch:
              - uma delas é o entendimento por padrão do JSON
              - é possível setar uma base url, que é aquela url que vai se repetir para todas as chamadas da API

      - Quando nos deparamos com um trecho de código que se repete em todas as páginas?
        - realizamos a adição da biblioteca axios como citado acima 
        - criamos um folder services dentro do src e também o arquivo api.ts
        - no arquivo api.ts:
          - realizamos o import:import axios from 'axios';
          - criamos uma constante para fazer a chamada do trecho base da url:
              - export const api = axios.create({
                  baseURL: 'http://localhost:3333/'
                })
          - após o processo acima, podemos codar desta forma:
            export const getStaticProps: GetStaticProps = async () => {
              const response = await api.get('http://localhost:3333/episodes?_limit=12&_sort=published_at&_order=desc')
              const data = response.data    //antes: const data = await response.json()

              /* código omitido */
              
              }
            }

            ou também podemos desestruturar:
             - const { data } = await api.get('episodes?_limit=12&_sort=published_at&_order=desc')
             e deletar a linha const data = response.data

          - outro parâmetro que podemos passar com auxílio do axios também deixando o endereço mais interessante,
           passando assim um array de objetos de configurações e dentro do objeto, o axios permite escrever estes 
           parâmetros da rota em formato Javascript e não somente como texto.
            - await api.get('episodes',{
                params: {
                  _limit: 12, 
                  _sort: 'published_at',
                  _order: 'desc'
                }
            })

          - Trabalhando agora com os dados consumidos pela nossa API, ou seja, vindos do Back-end:
              - retiramos aquela parte do stringify que estava send realizado no return da function,
              como podemos ver a seguir:
                export default function Home(props: HomeProps) {
                  return (
                    <div>
                      <h1>Index</h1>
                      <p>{JSON.stringify(props.episodes)}</p> <- aqui retiramos tudo que está entre {}
                    </div>
                  )
                }

              - resultando assim:
                export default function Home(props: HomeProps) {
                  return (
                    <div>
                      <h1>Index</h1>
                      <p>{JSON.stringify(props.episodes)}</p> <- aqui retiramos tudo que está entre {}
                    </div>
                  )
                }

                e dentro agora do getStaticProps, vamos criar uma const episodes:
                  const episodes = data.map(episode => {
                    return {
                      id: episode.id,
                      title: episode.title,
                      thumbnail: episode.thumbnail,
                      members: episode.members,
                      publishedAt: 
                    }
                  })

                Antes de completar a chamada da data, foi preciso importar duas funções do date-fns:
                import { format, parseISO } from 'date-fns';
                  - parseISO serve para pegar uma data(ex.: data no format string) e converter para um date do javascript,
                  resultando assim:
                      - publishedAt: format(parseISO(episode.published_at),'d MMM YY'); // d -> dia | MMM -> mês | YY -> ano

                - agora envolvendo a questão de duração do podcast, iremos fazer o seguinte:
                  - criamos um folder chamado utils na raiz do projeto, dentro criamos o arquivo 
                  convertDurationToTimeString.ts, onde declaramos o seguinte:
                    export function convertDurationToTimeString(duration: number) {
                        // math.floor serve para arredondar para o menor número que sobra dessa divisão
                        const hours = math.floor(duration / 3600;)
                        const minutes = Math.floor((duration % 3600) / 60);
                        const seconds = duration % 60;

                        //faqzendo o map no array, com relação as unidade, onde 
                        //estarei convertendo cada unidade em uma string e utilizando a 
                        função padStart, onde, por exemplo a hora retornar como 2, 
                        essa função estará adicionando o 0 na frente do 2, resultando em 02
                        const finalResult = [hours, minutes, seconds]
                            .map(unit => String(unit).padStart(2,'0');
                      }

                    - ao salvarmos e inspecionar nossa página, no console estará mostrando o seguinte erro:
                      - Each child in a list should have a unique "key" prop.
                      - e porque esse erro?
                        - Quando realizamos um map ou uma estrutura de repetição dentro do react, precisamos obrigatoriamente
                        no primeiro elemento que vem logo dentro do return, adicionar uma propriedade, que é uma propriedade
                        somente para o react e esta se chama key, na verdade ela já existe em todos os componentes por padrão, 
                        dos elementos do react, mas precisamos colocar ela no primeiro elemento que vem dentro do map e iremos
                        colocar nesta propriedade, qual informação única que existe entre cada uma dos episódios, que seria o
                        id, pois, é um elemento que não se repete, por isso o usamos como chave para cada episódio da lista
                          - esta funcionalidade é justamente uma questão de performance.

  - Roteamento e slug
    - criação de uma URL amigável
    - Poderíamos até criar um /Episode, mas ficaria uma rota com nome genérico, mas que retratasse 
    de um único episode.
    - Para evitar o carregamento todo da tela, ao acessarmos um episode, podemos fazer da seguinte forma:
      - fazer o import: import Link from 'next/link';
      - na div que tem o className = styles.episodeDetails, tínhamos o seguinte:
        - <a href={`/episodes/${episode.id}`}>{episode.title}</a>
        - após inserirmos o import do link, este trecho ficara assim: 
              <div className={styles.episodeDetails}>
                <Link href={`/episodes/${episode.id}`}>
                  <a>{episode.title}</a>
                </Link>
                /* código omitido */
              </div>
        - ao fazer esta mudança, toda vez que acessarmos um episode, ele não 
        efetuara o carregamento de toda a página do 0, e sim, so o conteúdo da 
        própria página
        - Com o next não perdemos flexibilidade do react
        - muitas vezes por mais que estejamos utilizando dados parecidos em duas ou mais funções, 
        não necessariamente automatizar código, para deixar menos verboso, seja a melhor saída em typescript...
        porque na hora de efetuar manutenção, pode vir a dar problemas em partes do código que nao eram
        pra ocorrer, dando muito mais dor de cabeça posteriormente, mais vale um codigo nao automatizado, 
        porém, bem escrito e funcionando do que um automatizado, mas que possa dar erros futuramente.
    
    - como fazer o botão de retorno, efetuar o retorno para a página anterior?
        - Existem algumas formas de aplicar essa questão:
          - Uma delas é importar o Link: import Link from 'next/link';
          - 'colocar' o button inserido em um Link, da seguinte forma:
            <Link href="/">
              <button type="button">
                <img src="/arrow-left.svg" alt="Voltar" />
              </button>
            </Link>

            onde ao pressionar, será retornado para a home através do href="/".


- Aula 04:

- getStaticPaths é um método obrigatório ser utilizado em toda rota que esta utilizando
geração estática(getStaticProps) e que tenha parâmetros dinâmicos, ou seja, 
que tenha colchetes no name do arquivo.
- Então toda que tem o [], vai ser preciso informar  método getStaticPaths
- Entendendo o método: 
    - Principal momento em que o next vai gerar a página estática da nossa aplicação 
    é no momento do build
    - Anteriormente, aula 02 mais ou menos, foi comentado quando foi apresentado todo o 
    JSON em tela, nesta parte  Diego apresentou que a parte de geração estática, so funciona 
    no nosso projeto, se executarmos ele como se estivesse em produção, para isso
    criamos uma build do projeto, através d sudo yarn build, já com o servidor em 'pé', desta forma, 
    o servidor do next, gerou uma versão estática da página, da home... é possivel verificar 
    no terminal que está rodando a build
    - Se o next so gera essa versão estática somente no momento de rodar o build, cmo vai construir uma 
    versão estática da página de episódios, se no momento da build ele nã sabe qual episódio desejamos gerar uma 
    versão estática.
    - Para isso temos o slug, que é uma versão dinâmica
    - no getStaticPaths, se faz o seguinte: defini quais episódios eu quero gerar de forma estática no 
    momento da build
        - a passarmos paths: [], significa que nã vai ser gerado de forma estática nenhum episódio no momento
        da build
        - se no lugar dos paths a gente retornasse um parâmetro(Objeto), passando primeiramente 
        params e inserindo o slug, ficaria da seguinte forma:

        export const getStaticPaths: GetStaticPaths = async () => {
          return {
            paths: [
              { 
                params: { 
                  slug: 'a-importancia-da-contribuicao-em-open-source' 
                } 
              }
            ],
            fallback: 'blocking'
          }
        }

        - Uso do fallback: 
          - ao passarmos o paths vazio, o build não vai gerar nenhum objeto de forma estática, 
          ou seja, nenhuma página vai ser gerada no momento da build, mas o que determina o comportamento
          de quando uma pessoa acessa a página / um episódio que não foi gerado estaticamente:
          é o fallback
           - ao passar o fallback false, o que acontece é o seguinte, se a pessoa acessar a página estática
           de um episódio e esse episódio não foi gerado no momento da build, ou seja, ele não foi passado 
           dentro dos paths, ele vai retornar 404, ou seja, não encontrado
           - a definir o fallback como true e alguém acessar um episódio e esse episódio, não foi gerado 
           anteriormente de forma estática, ele vai tentar buscar os dados daquele novo episódio, 
           que a pessoa ta acessando, para criar uma página estática daquele episódio, depois salvar o disco,
           mas o fallback:true, faz com que a requisição para buscar  os dados de um episódio, essa requisição
           que esta dentro do getStaticProps, a chama API, aconteça pelo lado do client, ou seja, pélo lado
           do browser


      - Arquitetura: 

          - client(browser) - next.js (node.js) - server (back-end)
          - ao alterarmos o fallback para true, ele rodaria no client(browser)
          - ao alterarmos o fallback para blocking, ee rodaria no next.js (node.js)
          

      - A utilizar o fallback como blocking, estará executando o processo em si na camada do 
      next.js e iss resultara em, quando a pessoa clicar no link, a pessoa so vai ser navegada 
      pra tela, quando os dados já estiverem sido carregados. Para questões de SO, essa é a melhor opção.
      Porque se caso um crawler for acessar um conteúdo da nossa aplicação, que ainda não foi gerado 
      de forma estática, esse conteúdo também, digamos a página vai aguardar o conteúdo ser carregado, 
      para ai então ser exibido.

      - após toda essa gama de informações, qual seria o mais recomendado?
        - imaginamos a criação de um e-commerce, onde temos duas entidades principais: categorias e produtos
        - imaginamos de maneira fictícia, que o e-commerc, tenha 50 categorias
        - no paath podemos passar as 50 categorias, desta forma, no momento do build o next 
        já vai construir a página dessas 50 categorias e vai deixar pronto para acesso dos usuários
        ou podemos pensar em somente aquelas categorias que mais são acessadas
        -  então, iríamos no back-end, fazemos uma requisição fetch e buscamos as categorias mais acessadas
        ou episódios de podcast mais acessados... Quando fazemos isso e passamos no path, no momento da build, 
        o next vai gerar estaticamente somente os que são mais acessados e o restante, como foi passado 
        fallback cmo blocking, vai sendo gerado conforme as pessoas vão acessando, ou seja, conforme os usuários 
        acessam a página, estas são geradas de forma estática.
        - este processo se chama incremental static regeneration


    - ContextAPI:
      - Uma funcionalidade do React que permite compartilhar dados entre componentes da nossa aplicação

      - Efetuando a comunicação dos componentes, para reproduzir um som e mostrar qual episode esta tocando ao 
      clicar no button de play
        - mas como fazer isso?
          - Inicialmente criamos um folder dentro do src(aplicação), com nome de contexts
          - dentro de contexts, criaremos o PlayerContext.ts
              - Onde, iremos importar o createContext do react e criar uma const PlayerContext do tipo 
              createContext:
                    import { createContext } from 'react';

                    //passando um valor padrão para o CreateContext, só para definir o formato dos dados que
                    //serão salvos neste componente
                    export const PlayerContext = createContext(''); 
              - Após o passo anterior, é preciso acessar o _app.tsx, ir até aonde se localiza o 
              componente que carrega toda a home e o player e 'envolver', através de um componente 
              que existe dentro do PlayerContext, da seguinte forma:
                  <PlayerContext.Provider value={'Brunno'}>
                    <div className={styles.wrapper}>
                      <main>
                        <Header />
                        <Component {...pageProps} />
                      </main>
                      <Player />
                    </div>
                  </PlayerContext.Provider>

            - Agra dentro do _app.tsx, criamos a função play, passando como parâmetro
            um episode e irá 'jogar' dentro da episodeList, através do setEpisodeList([episode]) 
            e o setCurrentEpisodeIndex(0), ou seja, forçando seu valor para zero, caso ainda não tenha 
            retornado, ficando assim a função:
              function play(episode) {
                setEpisodeList([episode]);
                setCurrentEpisodeIndex(0);
              }

              - mas como acessaremos essa função no component da Home ?
                - Passamos a função play também no PlayerContext, porém, inicialmente dará erro, 
                pois precisamos identificar na tipagem que existe uma função play:
                  - Acessamos  PlayerContext.ts
                    - e inserimos a função na tipagem:
                        type PlayerContextData = {
                          episodeList: Episode[];
                          currentEpisodeIndex: number;
                          play: (episode: Episode) => void;
                        };

                        - desta forma no _app, vi parar de dar um erro.
                        - agra na Home, podemos ir ate o button de play, chamar uma função de click,
                        precisamos criar uma arrow function, passando a function play e como parâmetro, 
                        passamos um episode e agra tudo funciona ja de maneira harmonica:
                            <button type="button" onClick={() => play(episode)}>
                              <img src="/play-green.svg" alt="Tocar episódio" />
                            </button>

                        - agora pra finalizar esta parte, vamos direto no Player, presente
                        em /Player/index.tsx
                          - nas informações do player, buscaremos o episodeList e o currentEpisodeIndex
                          e para determinar qual episódio que esta Tocando, basicamente pegamos nossa
                          episodeList e passamos como parâmetro o currentEpisodeIndex, porém, 
                          se a lista estiver vazia, não vai retornar nada em episode, mas irei tratar essa 
                          questão...
                          - agora no return, dentro do Header, ande está o tocando agora iremos passar o 
                          title do episode, para mostrar qual podcast está tocando, ficando tudo assim:

                              informações do player:
                                const { episodeList, currentEpisodeIndex} = useContext(PlayerContext)

                                const episode = episodeList[currentEpisodeIndex]

                              Header: 
                                <header>
                                  <img src="/playing.svg" alt="Tocando agora" />
                                  <strong>Tocando agora {episode?.title}</strong>
                                </header>

                                Obs.: O operador ?, é um operador ternário, aonde será verificado 
                                antes se tem algum tipo de valor, para ai então, o title ser mostrado.


              - Agora finalizar as funcionalidades e conseguir fazer o audio sair tocando:
                  - Personalizando o player: 
                      em styles.module.scss, faremos assim:
                        .currentEpisode {
                          text-align: center;

                          img {
                            border-radius: 1.5rem;
                          }

                          strong {
                            display: block;
                            margin-top: 2rem;
                            font: 600 1.25rem lexend,sans-serif;
                            line-height: 1.75rem;
                          }

                          span {
                            display: block;
                            margin-top: 1rem;
                            opacity: 0.6;
                            line-height: 1.5rem;
                          }

                        }

                        e no index.tsx do player, colocamos um ternário, para deixar ou não os buttons de reprodução
                        ativos ou não.
                        <footer className={!episode ? styles.empty : ''}>
                            //código omitido
                        </footer>

                  
                  - mexendo agora no slider do player:
                    - usaremos uma lib chamada rc-slider:
                        - sudo yarn add rc-slider
                        - no home do player, vamos importar algumas coisas:
                          - import Slider from 'rc-slider'; && import 'rc-slider/assets/index.css';
                        - Ainda no home, vamos mexer no footer para criar e estilizar o slider:
                            <footer className={!episode ? styles.empty : ''}>
                              <div className={styles.progress}>
                                <span>00:00</span>
                                <div className={styles.slider}>
                                    { episode ? (
                                      <Slider 
                                        trackStyle = {{ backgroundColor: '#04d361' }}
                                        railStyle = {{ backgroundColor: '#9f75ff' }}
                                        handleStyle = {{ borderColor: '#04d361', borderWidth: 4}}
                                      />
                                    ) : (
                                      <div className={styles.emptySlider} />
                                    )}
                                </div>
                                <span>00:00</span>
                              </div>

                              /* código omitido */

                            </footer>

                - Fazer o botão de play/pause realmente iniciar e parar a reprodução do episódio:
                   - A tag audio é uma tag nativa do HTML, para conseguir controlar o elemento audio, usando 
                   javascript, é preciso ter uma forma de acessar este elemento de uma forma imperativa, preciso
                   conseguir acessar este elemento e executar funções lá dentro...
                    - por exemplo, no javascript tradicional, fazemos assim:
                        - document.getElementById('').play

                    - quando precisamos fazer isso no React, a gente precisa acessar um elemento nativo, 
                    realizar uma ação nele de forma manual, como um foco em um input, chamamos esta ação no 
                    react de refs, ou seja, precisamos criar uma referência para aquele elemento que iremos 
                    manipular, então dentro do index.tsx do Player:
                        - criamos uma referência: 
                            - uma boa prática é criar a referencia como null
                            - neste ponto também utilizamos typescript
                            - Ao utilizarmos typescript com HTML, ao colocarmos o HTMLAudioElement, pois, estamos armazenando
                            um elemento de audio do HTML, fornecendo assim uma inteligência no momento que eu for utilizar
                            essa referência do aúdio, para saber quais métodos existem lá dentro, quais informações, o que eu posso 
                            utilizar
                                const audioRef = useRef<HTMLAudioElement>(null); //função que vem dentro do react

                                - agora dentro do audio em si, é passado a ref:
                                    { episode && (
                                      <audio 
                                        src={ episode.url }
                                        ref={ audioRef }
                                        autoPlay
                                      />
                                    )}


                